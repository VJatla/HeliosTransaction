import pandas as pd
import numpy as np
import math
from scipy.spatial import distance as scipy_dist
import cv2
from matplotlib import pyplot as plt
from astropy.io import fits
import pdb
import pickle
import sys
import os
cur_dir = os.path.dirname(__file__)
sys.path.insert(0,cur_dir+'/../blobTools/')
from BlobTools import *
sys.path.insert(0,cur_dir+'/../') # adding this directory for ViewOutput
import ViewOutput as disp # can be removed after finishing development

class LoadExpData:
    """
    Provides methods that loads and extract generated, removed and
    matchable clusters from FITS files created through matching
    frame work.
    """

    def choose_date_model(self, full_path, DEBUG_FLAG):
        """
        A fine control is provided where one can select date and
        model to be considered for feature extraction. This method
        forms a data frame out of excel sheet where

            - Row index is ``date``
            - Column index is ``model``

        For example if you have two dates, 20100713 and 20100714, and two
        models, model1 and model2 then the excel sheet is

        ==================   ============       ================
        Date                 model1             model2
        ==================   ============       ================
        20100713                1               0
        20100714                0               1
        ==================   ============       ================

        **1** in above table implies that we consider corresponding
        date and model for creating features. **0** implies the
        converse.

        :param full_path: full path to excel sheet, including it's name.
        :param DEBUG_FLAG: 1 prints the dataframe created.

        :Example:
        >>> import os
        >>> from GenRem import LoadGenRem
        >>> dir = os.path.dirname(__file__)
        >>> gr_obj = LoadGenRem()
        >>> gr_obj.create_training_table(dir+'/testCases/GenRem.xls',1)
       """
        valid_set = pd.read_excel(full_path)
        valid_set.index = valid_set['Date']
        valid_train_set = valid_set.drop('Date', 1)
        if(DEBUG_FLAG):
            print(valid_train_set)
        return valid_train_set

    def extract_imgs(self, date, path, model, DEBUG_FLAG):
        """
        Extracs generated, removed and matchable clusters from
        FITS image files generated by subjective matching
        framework. Returns 4D ndarrys where positive and
        negative are seperated in 4th dimentison (or)
        3rd axis as per numpy.

        :param date: Date being analyzed.
        :param path: Path to expert generated data.
        :param model_num: WSA model number under consideration
        :param DEBUG_FLAG: Displays binary images created.
        :returns, labelled image ??? needs better description:

            - 4th dimension represents positive and negative while
              3rd dimension has four channels having following
              labelled images.

                - Channel 0 = Generated coronal hole clusters.
                - Channel 1 = Removed coronal hole clusters.
                - Channel 2 = WSA model coronal hole clusters.
                - Channel 3 = Consensus coronal hole clusters.
        """
        path = path
        name = date + model + 'Matched.fits'
        fits_data = fits.open(path+name)
        all_imgs = fits_data[0].data
        con_match = all_imgs[1]
        wsa_match = all_imgs[4]

        # Extracting consensus clustering information
        con_pol = all_imgs[2]
        wsa_pol = all_imgs[5]
        con_clus = np.floor(con_match/10).astype('uint8')
        wsa_clus = np.floor(wsa_match/10).astype('uint8')

        # Extracting separating generated and removed coronal holes
        #   Since these are labelled 10*(label) + 2 when we modulo
        #   con_clus by 10 and then divide by 2 only generated or removed
        #   coronal holes reamin to be 1. Rest of them become fractional or 0.
        gen = np.floor(np.mod(wsa_match, 10)/2).astype('uint8')
        gen_lab = gen*wsa_clus
        rem = np.floor(np.mod(con_match, 10)/2).astype('uint8')
        rem_lab = rem*con_clus

        # Creating matchable coronal holes image
        #   This is created by removing generated and removed
        #   coronal hoels from wsa_clus and con_clus respectively.
        con_match_lab = con_clus - rem_lab
        wsa_match_lab = wsa_clus - gen_lab

        # Separating positive and negative coronal holes
        gen_pos = gen_lab*(wsa_pol > 0)
        gen_neg = gen_lab*(wsa_pol < 0)
        rem_pos = rem_lab*(con_pol > 0)
        rem_neg = rem_lab*(con_pol < 0)
        con_match_pos = con_match_lab*(con_pol > 0)
        con_match_neg = con_match_lab*(con_pol < 0)
        wsa_match_pos = wsa_match_lab*(wsa_pol > 0)
        wsa_match_neg = wsa_match_lab*(wsa_pol < 0)

        # Making a 3D array of positve and negatives.
        pos_bin_imgs = np.dstack((gen_pos,
                                  rem_pos,
                                  wsa_match_pos,
                                  con_match_pos))
        neg_bin_imgs = np.dstack((gen_neg,
                                  rem_neg,
                                  wsa_match_neg,
                                  con_match_neg))

        if(DEBUG_FLAG):
            plt.figure()
            plt.imshow(gen_lab, cmap="gray")
            plt.figure()
            plt.imshow(rem_lab, cmap="gray")
            plt.figure()
            plt.imshow(con_matchable, cmap="gray")
            plt.figure()
            plt.imshow(wsa_matchable, cmap="gray")
            plt.show()
        return np.concatenate((pos_bin_imgs[:, :, :, None],
                               neg_bin_imgs[:, :, :, None]), axis=3)


class ExtractFeatures(BlobTools):
    """
    Provides methods that calculates features for selected dates and
    models. Previous features are retained if it's not selected for
    update.

    Excel file containing features is assumed to have three sheets
    *gen, rem and match*. Each sheet structure is as follows

        ==================   ============       ================    ====
        Date                 model1             model2              ...
        ==================   ============       ================    ====
        20100713                '22,23'         '34,23,...'         ...
        20100714                '23'            '23,11,90,...'      ...
        ...                     ...             ...                 ...
        ==================   ============       ================    ====

    Please note that values of each cell is a string of comma separated values.
    """
    def load_old_features(self, path, feat_type):
        """
        Reads in previous features and creates a data frame.

        :param path: path to excel file containing features
        :param feat_type: Type of feature this is under consideration.

        .. Note::
            Excel file name is assumed to be ``<feat_type>.xls``
        """
        # Generated coronal holes
        self.gen_df = pd.read_excel(path+feat_type+'.xls', 'gen',
                                     converters={'model1': str, 'model2': str,
                                                 'model3': str, 'model4': str,
                                                 'model4': str, 'model5': str,
                                                 'model6': str, 'model7': str,
                                                 'model8': str, 'model9': str,
                                                 'model10': str,
                                                 'model11': str,
                                                 'model12': str})
        self.gen_df.index = self.gen_df['Date']
        self.gen_df = self.gen_df.drop('Date', 1)
        # Removed coronal holes
        self.rem_df = pd.read_excel(path+feat_type+'.xls', 'rem',
                                     converters={'model1': str, 'model2': str,
                                                 'model3': str, 'model4': str,
                                                 'model4': str, 'model5': str,
                                                 'model6': str, 'model7': str,
                                                 'model8': str, 'model9': str,
                                                 'model10': str,
                                                 'model11': str,
                                                 'model12': str})
        self.rem_df.index = self.rem_df['Date']
        self.rem_df = self.rem_df.drop('Date', 1)

        # Matchable coronal holes
        self.mat_df = pd.read_excel(path+feat_type+'.xls', 'match',
                                     converters={'model1': str, 'model2': str,
                                                 'model3': str, 'model4': str,
                                                 'model4': str, 'model5': str,
                                                 'model6': str, 'model7': str,
                                                 'model8': str, 'model9': str,
                                                 'model10': str,
                                                 'model11': str,
                                                 'model12': str})
        self.mat_df.index = self.mat_df['Date']
        self.mat_df = self.mat_df.drop('Date', 1)

    def write_features(self, path, feature_type):
        """
        Writes data frames updated with latest features. It creates an
        excel page with *gen, rem and match* sheets that follow the same
        structure discussed in ``class GRFeatures``.

        :param path: Path to where excel file needs to be written.
        :param feature_type: Feature that is being written

        """
        writer = pd.ExcelWriter(path+feature_type+'.xls', engine='xlsxwriter')
        self.gen_df.to_excel(writer, sheet_name='gen')
        self.rem_df.to_excel(writer, sheet_name='rem')
        self.mat_df.to_excel(writer, sheet_name='match')
        writer.save()

    def rect_dist(self, all_lab_imgs, date, model):
        """
        :param all_lab_imgs: 4D image, output of ``class LoadGenRem:: extract_imgs``.
        :param date: Date under consideration.
        :param model: Model under consideration.
        """
        gen_sd_lst = list()
        rem_sd_lst = list()
        mat_sd_lst = list()
        for pol_idx in range(0, all_lab_imgs.shape[3]):
            lab_imgs = all_lab_imgs[:, :, :, pol_idx]
            # Finding shortest distace of generated cluster with
            # respect to consensus image.
            sd_lst = list()
            gen = lab_imgs[:, :, 0]
            con = lab_imgs[:, :, 1] + lab_imgs[:, :, 3]
            for cur_lab in np.unique(gen[np.nonzero(gen)]):
                cur_gen_ch = (gen == cur_lab).astype('uint8')
                cur_rect_sd = self.calc_rect_sd(cur_gen_ch, con)
                sd_lst.append(cur_rect_sd)
            gen_sd_lst.append(sd_lst)

            # Finding shortest distance of removed clusters with
            # respect to model image
            sd_lst = list()
            rem = lab_imgs[:, :, 1]
            wsa = lab_imgs[:, :, 0] + lab_imgs[:, :, 2]
            for cur_lab in np.unique(rem[np.nonzero(rem)]):
                cur_rem_ch = (rem == cur_lab).astype('uint8')
                cur_rect_sd = self.calc_rect_sd(cur_rem_ch, wsa)
                sd_lst.append(cur_rect_sd)
            rem_sd_lst.append(sd_lst)

            # Finding shortest distance between matchable coronal holes
            sd_lst = list()
            con_mat = lab_imgs[:, :, 3]
            wsa = lab_imgs[:, :, 0] + lab_imgs[:, :, 2]
            for cur_lab in np.unique(con_mat[np.nonzero(con_mat)]):
                cur_con_mat_ch = (con_mat == cur_lab).astype('uint8')
                cur_rect_sd = self.calc_rect_sd(cur_con_mat_ch, wsa)
                sd_lst.append(cur_rect_sd)
            mat_sd_lst.append(sd_lst)

        # Writing new features to data frame
        gen_sd_lst = sum(gen_sd_lst, [])  # flattening the list
        gen_sd_str = ','.join(map(str, gen_sd_lst))
        self.gen_df.set_value(date, model, gen_sd_str)
        rem_sd_lst = sum(rem_sd_lst, [])  # flattening the list
        rem_sd_str = ','.join(map(str, rem_sd_lst))
        self.rem_df.set_value(date, model, rem_sd_str)
        mat_sd_lst = sum(mat_sd_lst, [])  # flattening the list
        mat_sd_str = ','.join(map(str, mat_sd_lst))
        self.mat_df.set_value(date, model, mat_sd_str)


    def calc_rect_sd(self, ch_img, map_img):
        """
        Calculates shortest distance between a coronal hole cluster and complete
        map of particular polarity.

        :param ch_img: Binary image having coronal hole cluster.
        :param map_img: Binary image having map of clusters to which we need
                        shortest distance.
        :returns sd: Shortest distance.
        """
        # copying images as opnecv destorys oroginal images
        map_img_copy = np.copy(map_img)
        ch_img_copy = np.copy(ch_img)
        # Checking if there is any overlap between ch_img and map_img
        overlap_img = ch_img * map_img # element wise multiplicaiton
        if len(np.unique(overlap_img)) > 1:  # if there is one more element other than 0 then
               sd = 0                       # there is overlap
               return sd
        # Building map contours
        map_contours_idx, hierarchy = cv2.findContours(map_img_copy, cv2.RETR_TREE,
                                                    cv2.CHAIN_APPROX_SIMPLE)
        # Building ch_img contour
        ch_contours_idx, hierarchy = cv2.findContours(ch_img_copy, cv2.RETR_TREE,
                                                    cv2.CHAIN_APPROX_SIMPLE)
        map_cnt_idx = np.squeeze(np.concatenate(np.array(map_contours_idx)))
        ch_cnt_idx = np.squeeze(np.concatenate(np.array(ch_contours_idx)))
        all_dist = scipy_dist.cdist(map_cnt_idx,ch_cnt_idx,'euclidean')
        sd = np.amin(all_dist)
        return sd

    def pixel_area_diff(self, all_lab_imgs, date, model):
        """
        Creates pixel area difference feature.

        :param all_lab_imgs: 4D image, output of ``class LoadGenRem:: extract_imgs``.
        :param date: Date under consideration.
        :param model: Model under consideration.
        """
        gen_ad_lst = list()
        rem_ad_lst = list()
        mat_ad_lst = list()
        for pol_idx in range(0, all_lab_imgs.shape[3]):
            lab_imgs = all_lab_imgs[:, :, :, pol_idx]
            # Finding shortest distace of generated cluster with
            # respect to consensus image.
            ad_lst = list()
            gen = lab_imgs[:, :, 0]
            con = lab_imgs[:, :, 1] + lab_imgs[:, :, 3]
            for cur_lab in np.unique(gen[np.nonzero(gen)]):
                cur_gen_ch = (gen == cur_lab).astype('uint8')
                cur_pixel_ad = self.calc_pixel_ad(cur_gen_ch, con)
                ad_lst.append(cur_pixel_ad)
            gen_ad_lst.append(ad_lst)

            # Finding shortest distance of removed clusters with
            # respect to model image
            ad_lst = list()
            rem = lab_imgs[:, :, 1]
            wsa = lab_imgs[:, :, 0] + lab_imgs[:, :, 2]
            for cur_lab in np.unique(rem[np.nonzero(rem)]):
                cur_rem_ch = (rem == cur_lab).astype('uint8')
                cur_pixel_ad = self.calc_pixel_ad(cur_rem_ch, wsa)
                ad_lst.append(cur_pixel_ad)
            rem_ad_lst.append(ad_lst)

            # Finding shortest distance between matchable coronal holes
            ad_lst = list()
            con_mat = lab_imgs[:, :, 3]
            wsa = lab_imgs[:, :, 0] + lab_imgs[:, :, 2]
            for cur_lab in np.unique(con_mat[np.nonzero(con_mat)]):
                cur_con_mat_ch = (con_mat == cur_lab).astype('uint8')
                cur_pixel_ad = self.calc_pixel_ad(cur_con_mat_ch, wsa)
                ad_lst.append(cur_pixel_ad)
            mat_ad_lst.append(ad_lst)

        # Writing new features to data frame
        gen_ad_lst = sum(gen_ad_lst, [])  # flattening the list
        gen_ad_str = ','.join(map(str, gen_ad_lst))
        self.gen_df.set_value(date, model, gen_ad_str)
        rem_ad_lst = sum(rem_ad_lst, [])  # flattening the list
        rem_ad_str = ','.join(map(str, rem_ad_lst))
        self.rem_df.set_value(date, model, rem_ad_str)
        mat_ad_lst = sum(mat_ad_lst, [])  # flattening the list
        mat_ad_str = ','.join(map(str, mat_ad_lst))
        self.mat_df.set_value(date, model, mat_ad_str)

    def calc_pixel_ad(self, ch_img, map_img):
        """
        Finds area difference between closest coronal hole clusters. Closeness
        is measured using euclidean distance.

        :param ch_img: Binary image having coronal hole cluster.
        :param map_img: Binary image having map of clusters to which we need
                        shortest distance.
        :returns sd: Shortest distance.
        """
        ch_img_copy = np.copy(ch_img) # as opencv destroys original image
        map_img_copy = np.copy(map_img)
        closest_ch = np.zeros(map_img.shape)
        # Building map contours
        map_contours_idx, hierarchy = cv2.findContours(map_img_copy, cv2.RETR_TREE,
                                                    cv2.CHAIN_APPROX_SIMPLE)
        # Building ch_img contour
        ch_contours_idx, hierarchy = cv2.findContours(ch_img_copy, cv2.RETR_TREE,
                                                    cv2.CHAIN_APPROX_SIMPLE)
        ch_cnt_idx = np.squeeze(np.concatenate(np.array(ch_contours_idx)))
        sd = 100000
        for idx in range(0,len(map_contours_idx)):
            cur_idx_squeezed = np.squeeze(np.concatenate(np.array(map_contours_idx[idx])))
            all_dist = scipy_dist.cdist(cur_idx_squeezed,ch_cnt_idx,'euclidean')
            cur_sd = np.amin(all_dist)
            if cur_sd < sd:
                sd = cur_sd
                closest_ch_idx = idx
        cv2.drawContours(closest_ch, map_contours_idx, closest_ch_idx, 1, -1)
        area_diff = abs(np.count_nonzero(closest_ch) - np.count_nonzero(ch_img))
        return area_diff

    def sph_dist(self, all_lab_imgs, date, model):
        """
        Shortest shperical distance between coronal hole and map.

        :param all_lab_imgs: 4D image, output of ``class LoadGenRem:: extract_imgs``.
        :param date: Date under consideration.
        :param model: Model under consideration.
        """
        height = all_lab_imgs.shape[0]
        width = all_lab_imgs.shape[1]
        sph_coord_map = self.create_sph_coord_map(width, height)

        gen_sph_sd_lst = list()
        rem_sph_sd_lst = list()
        mat_sph_sd_lst = list()
        for pol_idx in range(0, all_lab_imgs.shape[3]):
            lab_imgs = all_lab_imgs[:, :, :, pol_idx]
            # Finding shortest distace of generated cluster with
            # respect to consensus image.
            sph_sd_lst = list()
            gen = lab_imgs[:, :, 0]
            con = lab_imgs[:, :, 1] + lab_imgs[:, :, 3]
            for cur_lab in np.unique(gen[np.nonzero(gen)]):
                cur_gen_ch = (gen == cur_lab).astype('uint8')
                cur_sph_sd = self.calc_sph_sd(cur_gen_ch, con, sph_coord_map)
                sph_sd_lst.append(cur_sph_sd)
            gen_sph_sd_lst.append(sph_sd_lst)


            # Finding shortest distance of removed clusters with
            # respect to model image
            sph_sd_lst = list()
            rem = lab_imgs[:, :, 1]
            wsa = lab_imgs[:, :, 0] + lab_imgs[:, :, 2]
            for cur_lab in np.unique(rem[np.nonzero(rem)]):
                cur_rem_ch = (rem == cur_lab).astype('uint8')
                cur_sph_sd = self.calc_sph_sd(cur_rem_ch, wsa, sph_coord_map)
                sph_sd_lst.append(cur_sph_sd)
            rem_sph_sd_lst.append(sph_sd_lst)

            # Finding shortest distance between matchable coronal holes
            sph_sd_lst = list()
            con_mat = lab_imgs[:, :, 3]
            wsa = lab_imgs[:, :, 0] + lab_imgs[:, :, 2]
            for cur_lab in np.unique(con_mat[np.nonzero(con_mat)]):
                cur_con_mat_ch = (con_mat == cur_lab).astype('uint8')
                cur_sph_sd = self.calc_sph_sd(cur_con_mat_ch, wsa, sph_coord_map)
                sph_sd_lst.append(cur_sph_sd)
            mat_sph_sd_lst.append(sph_sd_lst)

        # Writing new features to data frame
        gen_sph_sd_lst = sum(gen_sph_sd_lst, [])  # flattening the list
        gen_sph_sd_str = ','.join(map(str, gen_sph_sd_lst))
        self.gen_df.set_value(date, model, gen_sph_sd_str)
        rem_sph_sd_lst = sum(rem_sph_sd_lst, [])  # flattening the list
        rem_sph_sd_str = ','.join(map(str, rem_sph_sd_lst))
        self.rem_df.set_value(date, model, rem_sph_sd_str)
        mat_sph_sd_lst = sum(mat_sph_sd_lst, [])  # flattening the list
        mat_sph_sd_str = ','.join(map(str, mat_sph_sd_lst))
        self.mat_df.set_value(date, model, mat_sph_sd_str)


    def calc_sph_sd(self, ch_img, map_img, sph_coord_map):
        """
        Calculates shortest spherical distace between a coronal hole
        and map.
        """
        # Distance is zero when cronal holes overlap
        overlap_img = ch_img*map_img
        if (len(np.unique(overlap_img[np.nonzero(overlap_img)] > 0))):
                sph_sd = 0
                return sph_sd
        ch_img_copy = np.copy(ch_img) # as opencv destroys original image
        map_img_copy = np.copy(map_img)
        # Building map contours
        _, map_pts, hierarchy = cv2.findContours(map_img_copy, cv2.RETR_TREE,
                                                    cv2.CHAIN_APPROX_SIMPLE)
        map_pts = np.squeeze(np.concatenate(np.array(map_pts)))
        # Building ch_img contour
        _, ch_pts, hierarchy = cv2.findContours(ch_img_copy, cv2.RETR_TREE,
                                                    cv2.CHAIN_APPROX_SIMPLE)
        ch_pts = np.squeeze(np.concatenate(np.array(ch_pts)))
        if ch_pts.size <= 2:            # if there is only one point in ch_pts
            ch_pts = ch_pts.reshape(1,2)
        if map_pts.size <=2:
            map_pts = map_pts.reshape(1,2)
        sph_dist_list = list()
        for map_idx,pt_m in enumerate(map_pts):
            for ch_idx,pt_c in enumerate(ch_pts):
                if pt_m.size == 1 or pt_c.size == 1:
                    pdb.set_trace()
                sph_dist = self.calc_sph_dist_pts(pt_m, pt_c, sph_coord_map)
                sph_dist_list.append(sph_dist)
        sph_sd_ndarray = np.array(sph_dist_list)
        sph_sd = np.min(sph_sd_ndarray[~np.isnan(sph_sd_ndarray)])
        return sph_sd





    def sph_area_diff(self, all_lab_imgs, date, model):
        """
        Shortest shperical distance between coronal hole and map.

        :param all_lab_imgs: 4D image, output of ``class LoadGenRem:: extract_imgs``.
        :param date: Date under consideration.
        :param model: Model under consideration.
        """
        height = all_lab_imgs.shape[0]
        width = all_lab_imgs.shape[1]
        sph_coord_map = self.create_sph_coord_map(width, height)
        sph_area_map = self.create_sph_area_map(width, height)

        gen_sph_ad_lst = list()
        rem_sph_ad_lst = list()
        mat_sph_ad_lst = list()
        for pol_idx in range(0, all_lab_imgs.shape[3]):
            lab_imgs = all_lab_imgs[:, :, :, pol_idx]
            # Finding shortest distace of generated cluster with
            # respect to consensus image.
            sph_ad_lst = list()
            gen = lab_imgs[:, :, 0]
            con = lab_imgs[:, :, 1] + lab_imgs[:, :, 3]
            for cur_lab in np.unique(gen[np.nonzero(gen)]):
                cur_gen_ch = (gen == cur_lab).astype('uint8')
                cur_sph_ad = self.calc_sph_ad(cur_gen_ch, con, sph_coord_map, sph_area_map)
                sph_ad_lst.append(cur_sph_ad)
            gen_sph_ad_lst.append(sph_ad_lst)


            # Finding shortest distance of removed clusters with
            # respect to model image
            sph_ad_lst = list()
            rem = lab_imgs[:, :, 1]
            wsa = lab_imgs[:, :, 0] + lab_imgs[:, :, 2]
            for cur_lab in np.unique(rem[np.nonzero(rem)]):
                cur_rem_ch = (rem == cur_lab).astype('uint8')
                cur_sph_ad = self.calc_sph_ad(cur_rem_ch, wsa, sph_coord_map, sph_area_map)
                sph_ad_lst.append(cur_sph_ad)
            rem_sph_ad_lst.append(sph_ad_lst)

            # Finding shortest distance between matchable coronal holes
            sph_ad_lst = list()
            con_mat = lab_imgs[:, :, 3]
            wsa = lab_imgs[:, :, 0] + lab_imgs[:, :, 2]
            for cur_lab in np.unique(con_mat[np.nonzero(con_mat)]):
                cur_con_mat_ch = (con_mat == cur_lab).astype('uint8')
                cur_sph_ad = self.calc_sph_ad(cur_con_mat_ch, wsa, sph_coord_map, sph_area_map)
                sph_ad_lst.append(cur_sph_ad)
            mat_sph_ad_lst.append(sph_ad_lst)

        # Writing new features to data frame
        gen_sph_ad_lst = sum(gen_sph_ad_lst, [])  # flattening the list
        gen_sph_ad_str = ','.join(map(str, gen_sph_ad_lst))
        self.gen_df.set_value(date, model, gen_sph_ad_str)
        rem_sph_ad_lst = sum(rem_sph_ad_lst, [])  # flattening the list
        rem_sph_ad_str = ','.join(map(str, rem_sph_ad_lst))
        self.rem_df.set_value(date, model, rem_sph_ad_str)
        mat_sph_ad_lst = sum(mat_sph_ad_lst, [])  # flattening the list
        mat_sph_ad_str = ','.join(map(str, mat_sph_ad_lst))
        self.mat_df.set_value(date, model, mat_sph_ad_str)



    def create_sph_area_map(self, width, height):
        """
        Projecting area of pixel onto sphere
        """
        d_phi = np.pi/height
        d_theta = 2*(np.pi)/width
        phi_vec = np.arange(0, np.pi, d_phi)
        area_vec = np.sin(phi_vec)*d_phi*d_theta
        area_map = np.repeat(area_vec, 360)
        area_map = area_map.reshape(180,360)
        return area_map

    def calc_sph_ad(self, ch_img, map_img, coord_map, area_map):
        """
        Returns area difference between current coronal hole and
        it's comparison map
        """
        ch_img_cp = np.copy(ch_img)
        ch_img_area = self.get_sph_area(ch_img, area_map)
        sph_sd = 10000
        labels = np.unique(map_img[np.nonzero(map_img)])
        for idx,label in enumerate(labels):
            cur_map_ch = (map_img == label).astype('uint8')
            cur_map_ch_cp = np.copy(cur_map_ch)

            cur_sph_sd = self.calc_sph_sd(ch_img_cp, cur_map_ch_cp,
                                          coord_map)
            if cur_sph_sd < sph_sd:
                sph_sd = cur_sph_sd
                map_sd_clus = cur_map_ch
        map_ch_area = self.get_sph_area(map_sd_clus, area_map)
        area_diff = abs(map_ch_area - ch_img_area)
        return area_diff

    def get_sph_area(self, ch_img, area_map):
        """
        """
        return np.sum(ch_img*area_map)









class AnalyzeFeatures:
    """
    Provides methods to analyze features extraced using ``class GRFeatures``
    """
    def extract_features(self, path, feat_list, valid_dates):
        """
        Loads features from excel file and converts them to ``numpy ndarray``.

        :param path: Absolute path to excel files having features
        :param feature_type: Name of feature you would like to analyze.

        .. Note::
            Please note that excel file name is parsed to be *<``feature_type``>*.xls
        """
        gen_df = pd.DataFrame()
        rem_df = pd.DataFrame()
        mat_df = pd.DataFrame()

        for idx, cur_feat in enumerate(feat_list):
            cur_gen_df = pd.read_excel(path+cur_feat+'.xls', 'gen').astype(str)
            cur_rem_df = pd.read_excel(path+cur_feat+'.xls', 'rem').astype(str)
            cur_mat_df = pd.read_excel(path+cur_feat+'.xls', 'match').astype(str)
            
            cur_gen_df["feature"] = cur_feat
            cur_rem_df["feature"] = cur_feat
            cur_mat_df["feature"] = cur_feat
            
            gen_df = gen_df.append(cur_gen_df)
            rem_df = rem_df.append(cur_rem_df)
            mat_df = mat_df.append(cur_mat_df)

        gen_df = gen_df.loc[gen_df['Date'].isin(valid_dates)]
        rem_df = rem_df.loc[rem_df['Date'].isin(valid_dates)]
        mat_df = mat_df.loc[mat_df['Date'].isin(valid_dates)]
        return gen_df, rem_df, mat_df

    def create_np_features(self, df, feature_list):
        """
        Converts data frame to numpy array
        """
        for idx, feat in enumerate(feature_list):
            df_feat = df.loc[df['feature'] == feat]
            tmp = (df_feat.values[:,1:12]).flatten()
            tmp = np.asarray([x for x in tmp if str(x) != 'nan'])
            tmp = ",".join(tmp)
            if idx == 0:
                np_array = np.asarray(list(filter(None,tmp.split(",")))).astype(float)
                np_array = np_array.reshape(np_array.shape[0],1)
            else:
                cur_array = np.asarray(list(filter(None,tmp.split(",")))).astype(float)
                cur_array = cur_array.reshape(cur_array.shape[0],1)
                np_array = np.concatenate((np_array, cur_array),axis=1)
        return np_array

    def find_distance(self, arr):
        origin_arr = np.zeros((1, arr.shape[1]))
        arr_mdist = scipy_dist.cdist(arr, origin_arr, 'euclidean')
        arr = np.concatenate((arr, arr_mdist), axis=1)
        return arr

    def find_optimal_threshold(self, gen, rem, mat):
        """
        """
        # find the maximum mahalanobis distance 
        dist_max = np.amax(np.vstack((gen, rem, mat))[:,2])
        dist_min = np.amin(np.vstack((gen, rem, mat))[:,2])
        th_list = np.arange(dist_min,dist_max,(dist_max - dist_min)/10)
        th_list = np.append(th_list,dist_max)
        acc_list = np.zeros(th_list.shape)

        for idx,cur_th in enumerate(th_list):
            # Accurace = (Num_gr_c + num_m_c)/(tot_num_gr + tot_num_m)
            acc_list[idx] = self.calc_accuracy(cur_th, gen, rem, mat)

        best_th = th_list[np.argmax(acc_list)]
        return best_th

    def calc_accuracy(self, th, gen, rem, mat):
        gr = np.vstack((gen, rem))
        gr_tot = gr.shape[0]
        ma_tot = mat.shape[0]
        # Number of generated/removed that are
        # above threshold -- Correct
        gr_cor = np.count_nonzero(gr[:,2] > th)
        # Number of matchable that are below
        # threshold -- Correct
        mat_cor = np.count_nonzero(mat[:,2] <= th)
        # Accurace = (Num_gr_c + num_m_c)/(tot_num_gr + tot_num_m)
        acc = float(gr_cor + mat_cor)/float(gr_tot + ma_tot)
        return acc



































class Classify(ExtractFeatures, BlobTools):
    """
    Class having methods that help in classifying coronal holes as
    removed, generated and matchable.
    """

    def extract_gen_rem(self, con_imgs, wsa_imgs):
        """
        Extracts generated and removed coronal holes.

        :param con_imgs: Pre-processed binary images of consensusa.
        :param wsa_imgs: Pre-processed binary images of wsa model.
        :param method: Method to use for extracting.
        :param use_featues: list specifying features that can be
                            used.

        Method can be, euclidean, mahanalobis, KNN, etc

        use_features is a list that take following vlaues,
        rect_dist, sph_dist, area_diff.
        """
        gen = np.zeros(wsa_imgs.shape[0:2] + (2,)).astype('uint8')
        rem = np.zeros(con_imgs.shape[0:2] + (2,)).astype('uint8')

        # Polarity loop
        #   pol_idx = 0, implies positive polarity
        #   pol_idx = 1, implies negative polarity
        for pol_idx in range(0,2):
            cur_wsa = wsa_imgs[:, :, pol_idx]
            cur_con = con_imgs[:, :, pol_idx]

            # Generated coronal holes
            cur_wsa_lab = self.clus_poles(cur_wsa)
            labels = np.unique(cur_wsa_lab[np.nonzero(cur_wsa_lab)])
            for cur_lab in labels:
                cur_wsa_ch = (cur_wsa_lab == cur_lab).astype('uint8')
                cur_wsa_ch_copy= np.copy(cur_wsa_ch)
                matchable_flag = self.is_matchable(cur_wsa_ch, cur_con, 0.30418143488)
                if (matchable_flag==False):
                    gen[:, :, pol_idx] = gen[:, :, pol_idx] + cur_wsa_ch_copy

            # Removed coronal holes
            cur_con_lab = self.clus_poles(cur_con)
            labels = np.unique(cur_con_lab[np.nonzero(cur_con_lab)])
            for cur_lab in labels:
                cur_con_ch = (cur_con_lab == cur_lab).astype('uint8')
                cur_con_ch_copy = np.copy(cur_con_ch)
                matchable_flag = self.is_matchable(cur_con_ch, cur_wsa, 0.30418143488)
                if (matchable_flag==False):
                    rem[:, :, pol_idx] = rem[:, :, pol_idx] + cur_con_ch_copy

            # When one of the matchable case has no coronal holes while the other is
            # having some coronal holes case.
        gen, rem = self.no_matchable_ch(gen, rem, con_imgs, wsa_imgs)
        return gen, rem

    def is_matchable(self, ch_img, map_img, th):
        """
        Returns True if a coronal hole compared to map is matchable, else
        returns false
        """
        # If map image is blank then obviously ch_img is not matchable
        labels = np.unique(map_img[np.nonzero(map_img)])
        if (len(labels) < 1):
            return False
        width = ch_img.shape[1]
        height = ch_img.shape[0]
        sph_coord_map = self.create_sph_coord_map(width, height)
        sph_area_map = self.create_sph_area_map(width, height)
        sph_sd = self.calc_sph_sd( ch_img, map_img, sph_coord_map)
        # If ch_img overlaps with map_img then sph_sd = 0 and the coronal holes
        # are matchable
        if(sph_sd == 0): # Only if the coronal hole is polar ??? <-- Fix this
            return True
        sph_sd_area_diff = self.calc_sph_ad( ch_img, map_img, sph_coord_map, sph_area_map)
        # Euclidean distance from origin
        cur_pt = np.array([sph_sd, sph_sd_area_diff])
        origin = np.zeros((1, 2))
        dist = scipy_dist.pdist(np.vstack((origin, cur_pt)), 'euclidean')
        if dist <= th:
            return True
        else:
            return False


    def no_matchable_ch(self, gen, rem, con, wsa):
        
        con_mat = con[:, :, 0] - rem[:, :, 0]
        con_mat = np.dstack((con_mat, con[:, :, 1] - rem[:, :, 1]))
        wsa_mat = wsa[:, :, 0] - gen[:, :, 0]
        wsa_mat = np.dstack((wsa_mat, wsa[:, :, 1] - gen[:, :, 1]))
        # When there are no coronal holes in con_mat
        #   Positive
        cur_img = con_mat[:,:,0]
        con_uniq_lab = np.unique( cur_img [ np.nonzero(cur_img)] )
        if (con_uniq_lab.size == 0):
            gen[:,:,0] = gen[:,:,0] + wsa_mat[:,:,0]
        #   Negative
        cur_img = con_mat[:,:,1]
        con_uniq_lab = np.unique( cur_img [ np.nonzero(cur_img)] )
        if (con_uniq_lab.size == 0):
            gen[:,:,1] = gen[:,:,1] + wsa_mat[:,:,1]

        # When there are no coronal holes in wsa_mat
        #   Positive
        cur_img = wsa_mat[:,:,0]
        wsa_uniq_lab = np.unique( cur_img [ np.nonzero(cur_img)] )
        if (wsa_uniq_lab.size == 0):
            rem[:,:,0] = rem[:,:,0] + con_mat[:,:,0]
        #   Negative
        cur_img = wsa_mat[:,:,1]
        wsa_uniq_lab = np.unique( cur_img [ np.nonzero(cur_img)] )
        if (wsa_uniq_lab.size == 0):
            rem[:,:,1] = rem[:,:,1] + con_mat[:,:,1]

        return gen, rem
